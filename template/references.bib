
@article{thompson_programming_1968,
	title = {Programming {Techniques}: {Regular} expression search algorithm},
	volume = {11},
	issn = {0001-0782, 1557-7317},
	shorttitle = {Programming {Techniques}},
	url = {https://dl.acm.org/doi/10.1145/363347.363387},
	doi = {10.1145/363347.363387},
	abstract = {A method for locating specific character strings embedded in character text is described and an implementation of this method in the form of a compiler is discussed. The compiler accepts a regular expression as source language and produces an IBM 7094 program as object language. The object program then accepts the text to be searched as input and produces a signal every time an embedded string in the text matches the given regular expression. Examples, problems, and solutions are also presented.},
	language = {en},
	number = {6},
	urldate = {2026-01-05},
	journal = {Communications of the ACM},
	author = {Thompson, Ken},
	month = jun,
	year = {1968},
	pages = {419--422},
}

@article{systemf_linear_2024,
	title = {Linear {Matching} of {JavaScript} {Regular} {Expressions}},
	volume = {8},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3656431},
	doi = {10.1145/3656431},
	abstract = {Modern regex languages have strayed far from well-understood traditional regular expressions: they include features that fundamentally transform the matching problem. In exchange for these features, modern regex engines at times suffer from exponential complexity blowups, a frequent source of denial-of-service vulnerabilities in JavaScript applications. Worse, regex semantics differ across languages, and the impact of these divergences on algorithmic design and worst-case matching complexity has seldom been investigated.
            This paper provides a novel perspective on JavaScript’s regex semantics by identifying a larger-than-previously-understood subset of the language that can be matched with linear time guarantees. In the process, we discover several cases where state-of-the-art algorithms were either wrong (semantically incorrect), inefficient (suffering from superlinear complexity) or excessively restrictive (assuming certain features could not be matched linearly). We introduce novel algorithms to restore correctness and linear complexity. We further advance the state-of-the-art in linear regex matching by presenting the first nonbacktracking algorithms for matching lookarounds in linear time: one supporting captureless lookbehinds in any regex language, and another leveraging a JavaScript property to support unrestricted lookaheads and lookbehinds. Finally, we describe new time and space complexity tradeoffs for regex engines. All of our algorithms are practical: we validated them in a prototype implementation, and some have also been merged in the V8 JavaScript implementation used in Chrome and Node.js.},
	language = {en},
	number = {PLDI},
	urldate = {2025-12-07},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Barrière, Aurèle and Pit-Claudel, Clément},
	month = jun,
	year = {2024},
	pages = {1336--1360},
}

@misc{spike1236_virtual_2025,
	title = {Virtual trees method},
	journal = {codeforces.com},
	month = feb,
	year = {2025},
	url = {https://codeforces.com/blog/entry/140066}
}

@incollection{weirich_efficient_2024,
	address = {Cham},
	title = {Efficient {Matching} with {Memoization} for {Regexes} with {Look}-around and {Atomic} {Grouping}},
	volume = {14577},
	isbn = {9783031572661 9783031572678},
	url = {https://link.springer.com/10.1007/978-3-031-57267-8_4},
	abstract = {Abstract
            
              Regular expression (regex) matching
              is fundamental in many applications, especially in web services. However, matching by
              backtracking
              —preferred by most real-world implementations for its practical performance and backward compatibility—can suffer from so-called
              catastrophic backtracking
              , which makes the number of backtracking super-linear and leads to the well-known ReDoS vulnerability. Inspired by a recent algorithm by Davis et al. that runs in linear time for (non-extended) regexes, we study efficient backtracking matching for regexes with two common extensions, namely
              look-around
              and
              atomic grouping
              . We present linear-time backtracking matching algorithms for these extended regexes. Their efficiency relies on
              memoization
              , much like the one by Davis et al.; we also strive for smaller memoization tables by carefully trimming their range. Our experiments—we used some real-world regexes with the aforementioned extensions—confirm the performance advantage of our algorithms.},
	language = {en},
	urldate = {2026-01-05},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer Nature Switzerland},
	author = {Fujinami, Hiroya and Hasuo, Ichiro},
	editor = {Weirich, Stephanie},
	year = {2024},
	doi = {10.1007/978-3-031-57267-8_4},
	pages = {90--118},
}

@misc{russ_regular_2009,
	title = {Regular {Expression} {Matching}: the {Virtual} {Machine} {Approach}},
	url = {https://swtch.com/~rsc/regexp/regexp2.html},
	author = {Russ, Cox},
	month = dec,
	year = {2009},
}
